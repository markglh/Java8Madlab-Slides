<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Java 8 - The Good Stuff</title>

		<meta name="description" content="Java 8 - The Good Stuff!">
		<meta name="author" content="Mark Harrison">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Java 8 - The Good Stuff</h1>
					<h3>Lambdas, Streams, Optional...</h3>
					<p>
						<small>Created by <a href="https://github.com/markglh">Mark Harrison</a> / <a href="http://twitter.com/markglh">@markglh</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>Lambdas you say?</h2>
						<ul>
	         				<li>Basically just a shorthand method implementation</li>
	         				<li>Concise and <em>much</em> improved replacement for Anonymous inner classes</li>
	         				<li>Makes it easy to pass <em>behaviour</em> around</li>
	          				<li>Pass the behaviour into the method, flips the design on its head</li>
	          				<li>Lexically scoped (<code>this</code> is effectively shared with the surrounding method)</li>
	          				<li><em>Almost</em> closures</li>
	          			</ul>
						</p>
	          			<aside class="notes">
	          				<ul>
	          					<li>Lexical scoping - effectively recognises the scope of the surrounding method.</li>
	          					<li>“this” doesn’t refer to the lambda itself (as it would have with anonymous classes).</li>
	          					<li>lambdas can access the variables of the surrounding method (making them closures, almost)</li>
	          					<li>One caveat here is that the variables must be effectively final, they don’t need to have the final keyword, but the compiler will verify that they aren’t re-assigned.</li>
	          					<li>good performance, better than scala (sorry!)</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Syntax please!</h2>

						<pre><code data-trim class="java">
(int x, int y)   ->   x + y
	          			</code></pre>
	          			</br>

	          			<p>Argument types can be inferred by the compiler:</p>
	          			<pre><code data-trim class="java">
(x, y)   ->   x + y
	          			</code></pre>

	          			</br>

						<p>Zero-arg Lambdas are also possible:</p>
	          			<pre><code data-trim class="java">
()   ->   "Java 8!"
	          			</code></pre>
	          			</br>

						<p>But how can we use them?</p>
						<pre class="fragment fade-in" ><code data-trim class="java">
Consumer&lt;String&gt; inferredConsumer = x -> System.out.println(x);
	          			</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li>Multiple arguments need to be in parentheses</li>
	          					<li>The types can be inferred when mapping to the FunctionalInterface</li>
	          					<li>Can wrap large Lambdas in parenthesis but you should really use method references instead</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>WAT?!?</h2>
						<img src="images/watcat.jpg"/>
					</section>

					<section>
						<h2>Functional Interfaces</h2>
						<ul>
							<li>A Functional Interface is any interface with <em>one</em> <strong>S</strong>ingle <strong>A</strong>bstract <strong>M</strong>ethod</li>
							<li class="fragment fade-in">The parameters that the Lambda accepts and returns must match the interface (incuding exceptions)</li>
							<li class="fragment fade-in"><code>@FunctionalInterface</code> annotation is provided to highlight these interfaces, it is just a marker though, any <em>SAM</em> interface will work - the annotation simply enforces this at compile time</li>
						</ul>
						</ul>
						</br></br>
						<ul class="fragment fade-in">
							<li>So... When we pass or assign a Lambda:
								<ol>
									<li>First the Lambda is converted into a Functional Interface</li>
									<li>Secondly it is invoked via this generated implementation</li>
								</ol>	
							</li>
						</ul>						

	          			<aside class="notes">
	          				<ul>
	          					<li>A @FunctionalInterface has one (non default) method. </li>
	          					<li>Inference is used to try to match the interface to the lambda</li>
	          					<li>The annotation is just a marker, it isn't required for it to work, any interface with just one method is considered a functional interface!</li>
	          					<li>However, if the interface has more than one (non-default) method the annotation prevents it from compiling.</li>
	          					<li>Fully backwards compatible.</li>
	          					<li>A Lambda can replace any variable or parameter that expects a SAM interface</li>
	          					<li>The java.util.function package contains lots of <code>@FunctionalInterface</code> definitions</li>
	          					<li>Downside: Lots of different interfaces with different names (couldn’t do it like C# because of type erasure)</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 1 - Predicates</h2>
						<p>Have you ever written code like this?</p>

						<pre><code data-trim class="java">
@FunctionalInterface  //Added in Java8 
public interface Predicate&lt;T&gt; {
	boolean test(T t); 
	
}

private void printAllPeopleMatchingPredicate(List&lt;Person&gt; people, 
                                             Predicate&lt;Person&gt; predicate) {
    for (Person person : people) {
        if (predicate.test(person)) {
           System.out.println(person);
        }
    }
}						
						</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li>Predicate pattern, rather than hard coding the "if" statement</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 1 - Predicates</h2>

						<p>Pre Java 8:</p>

						<pre><code data-trim class="java">
class PersonOlderThan50Predicate implements Predicate&lt;Person&gt; {
    public boolean test(Person person) {
        return person.getAge() >= 50;
    }
}

printAllPeopleMatchingPredicate(loadsOfPeople, 
                                new PersonOlderThan50Predicate());
	          			</code></pre>
	          			</br>

	          			<aside class="notes">
	          				<ul>
	          					<li>Need to implement a predicate for each different test</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 1 - Predicates</h2>

						<p>Java 8:</p>

						<pre><code data-trim class="java">
printAllPeopleMatchingPredicate(loadsOfPeople, x -> x.getAge() > 50); 
	          			</code></pre>
	          			<p>Notice the signature matches that of the Predicate, the compiler automatically figures out the rest</p>
	          			</br>

	          			
		          		<p>What if we had an existing <code>Predicate</code> we wanted to enhance?</p>
		          		<div class="fragment fade-in">
		          			<pre><code data-trim class="java">
Predicate&lt;Person&gt; ageCheck = x -> x.getAge() > 50;
printAllPeopleMatchingPredicate(loadsOfPeople, 
                                ageCheck.and(x -> x.getIq() >100));
		          			</code></pre>
		          			<p>Composite <code>Predicates</code> FTW... :-)</p>
	          			</div>


	          			<aside class="notes">
	          				<ul>
	          					<li>Could pass another function in to execute on each element</li>
	          					<li>Execute around pattern</li>
	          					<li>Could use method references instead</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 2 - Runnable</h2>

						<p>Pre Java 8 mess:</p>

						<pre><code data-trim class="java">
Runnable r1 = new Runnable() {
    @Override
    public void run() {
         System.out.println("Meh!");
    }
};
r1.run();
	          			</code></pre>

	          			</br>
						<p>Java 8:</p>

						<pre><code data-trim class="java">
Runnable r = () -> System.out.println("Woop!");
r.run();
	          			</code></pre>
					</section>

					<section>
						<h2>Lambda Example 3 - Collections</h2>

						<p>Lambdas make lots of new Collection methods possible...</p>

						<pre><code data-trim class="java">
List&lt;String&gt; strings = new ArrayList&lt;&gt;();
Collections.addAll(strings, "Java", "7", "FTW");
	          			</code></pre>
	          			
	          			<div class="fragment fade-in">
		          			<p>Do <em>something</em> on every element in the List</p>
		          			<pre><code data-trim class="java">
strings.forEach(x -> System.out.print(x + " ")); 
//Prints: "Java 7 FTW"
		          			</code></pre>
	          			</div>
	          			
	          			<div class="fragment fade-in">
		          			<p>Replace every matching element in the List</p>
		          			<pre><code data-trim class="java">
strings.replaceAll(x -> x == "7" ? "8" : x); 
strings.forEach(x -> System.out.print(x + " "));
//Prints: "Java 8 FTW"
		          			</code></pre>
	          			</div>

						<div class="fragment fade-in">
		          			<p>Remove matching elements from the List</p>
		          			<pre><code data-trim class="java">
strings.removeIf(x -> x == "8");
strings.forEach(x -> System.out.print(x + " "));
//Prints: Java FTW
		          			</code></pre>
	          			</div>

	          			<aside class="notes">
	          				<ul>
	          					<li>This sets us up for streams later</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 4 - Comparators</h2>

						<pre><code data-trim class="java">
@FunctionalInterface //Added in Java8 version
public interface Comparator&lt;T&gt; {
	int compare(T o1, T o2);
	//Java 8 adds loads of default methods...
}
						</code></pre>

						<p>Pre Java 8:</p>

						<pre><code data-trim class="java">
class SortByPersonAge implements Comparator&lt;Person&gt; {
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge();
    }
}

List&lt;Person&gt; loadsOfPeople = ...;
Collections.sort(loadsOfPeople, new SortByPersonAge());

	          			</code></pre>

	          			<div class="fragment fade-in">
		          			<p>Java 8:</p>

							<pre><code data-trim class="java">
	Collections.sort(loadsOfPeople, (p1, p2) -> p1.getAge() - p2.getAge());
		          			</code></pre>
	          			</div>

	          			<aside class="notes">
	          				<ul>
	          					<li>Multiple arguments need to be in parenthesis</li>
	          					<li>The types can be inferred when mapping to the FunctionalInterface</li>
	          				</ul>
	          			</aside>
					</section>
				</section>

				<section>
						<h2>Lambda Example 4 - Comparators</h2>

						<p>As usual in Java 8... the <code>Comparator</code> interface provides plenty of useful default &amp; static methods...</p>
			
						<pre><code data-trim class="java">
//comparing static method simplifies creating Comparators
Comparator&lt;Person&gt; newComparator = Comparator.comparing(e -> e.getIq());
						</code></pre>

						<pre class="fragment fade-in"><code data-trim class="java">
//thenComparing allows composite comparators to be easily created
Collections.sort(loadsOfPeople, 
                 newComparator.thenComparing(
                               Comparator.comparing(e -> e.getIq())));
						</code></pre>

						<pre class="fragment fade-in"><code data-trim class="java">
//More useful Collection methods...
loadsOfPeople4.sort(Comparator.comparing(e -> e.getIq()));
						</code></pre>

						<pre class="fragment fade-in"><code data-trim class="java">
//And finally... Method references (I'll explain this soon!)
loadsOfPeople.sort(Comparator.comparing(Person::getAge));
						</code></pre>

	          			
	          			<aside class="notes">
	          				<ul>
	          					<li>Multiple arguments need to be in parenthesis</li>
	          					<li>The types can be inferred when mapping to the FunctionalInterface</li>
	          				</ul>
	          			</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Introducing Method References</h2>
						<ul>
							<li>Any method can be automatically “lifted” into a function. It must simply meet contract of the FunctionalInterface</li>
	          				<li>Can be easier to debug &amp; test than Lambdas, more descriptive stack traces</li>
	          				<li>Promotes re-use, keeping code <em>DRY</em></li>
	          				<li>Uses the &quot;<em>::</em>&quot; syntax</li>
	          			</ul>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Decision needs to be made on a case by case basis</li>
	          					<li>Generally method references are more readable and certainly more re-usable</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Method References Types</h2>
	          			<table>
							<thead>
								<tr>
									<th>Reference to...</th>
									<th>Example</th>
								</tr>
							</thead>
							<tbody>
								<tr>
								 	<td>a static method</td>
								 	<td><code class="java">Class::staticMethodName</code></td> 
								</tr>
								<tr>
									<td>an instance method of a <strong>specific</strong> object</td>
									<td><code class="java">Object::instanceMethodName</code></td> 
								</tr>
								<tr>
									<td>an instance method of an <strong>arbitrary</strong> object</td>
									<td><code class="java">Class::methodName</code></td> 
								</tr>
								<tr>
									<td>a constructor</td>
									<td><code class="java">ClassName::new</code></td> 
								</tr>
							</tbody>
						</table>
					</section>

					<section>
						<h2>Reference to a static method</h2>
						<p>A simple reference to a static method</p>
						<pre><code data-trim class="java">
//isPersonOlderThan50 is a static method on the PersonPredicates class
printAllPeopleMatchingPredicate(loadsOfPeople, 
                                PersonPredicates::isPersonOlderThan50);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
printAllPeopleMatchingPredicate(loadsOfPeople, x -> x.getAge() > 50);
						</code></pre>
	          			<aside class="notes">
	          				<ul>
	          					<li>...</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Reference to an instance method of a specific object</h2>
						<p>A reference to a method on an object instance</p>
						<pre><code data-trim class="java">
List&lt;String&gt; strings = ...
//print is a method on the "out" PrintStream object
strings.forEach(System.out::print);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
strings.forEach(x -> System.out.print(x));
						</code></pre>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Useful for saving a few characters but not the most widely used type</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Reference to an instance method of an arbitrary object</h2>
						<p>Although it looks like we're referencing a Class method, we're invoking an instance method on the object(s) passed in the call</p>
						<pre><code data-trim class="java">
public interface Function&lt;T,R&gt; {
	public R apply(T t);
}

public static &lt;T, R&gt; List&lt;R&gt; map(Function&lt;T, R&gt; function, List&lt;T&gt; source) {
        //applies the function to each element, converting it from T to R
}
						</code></pre>
						<pre><code data-trim class="java">
List&lt;Person&gt; loadsOfPeople = ...
List&lt;Integer&gt; namesOfPeople = map(Person::getAge, loadsOfPeople);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
List&lt;Integer&gt; namesOfPeople = map(person -> person.getAge(), loadsOfPeople);
						</code></pre>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Useful for saving a few characters but not the most widely used type</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Reference to a constructor</h2>
						<p>Uses the constructor to create new objects, the constructor signature must match that of the FunctionalInterface</p>
						<pre><code data-trim class="java">
List&lt;String&gt; digits = Arrays.asList("1", "2", "3", "4", "5");
						</code></pre>
						<pre><code data-trim class="java">
//Transforms a String into an Integer using the default Integer constructor
List&lt;Integer&gt; numbers = map(Integer::new, digits);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
List&lt;Integer&gt; numbers2 = map(s -> new Integer(s), digits);
						</code></pre>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Anytime you're simply creating a new object you may be able to swap the lambda for a constructor method reference</li>
	          				</ul>
	          			</aside>
					</section>
				</section>

				<section>
				    <section>
						<h2>What's wrong with Collections</h2>
						<ul>
							<li>Every application uses Collections, however Collections are difficult to query and aggregate, requiring several levels of iteration and conditionals, basically it’s messy and painful</li>
							<li>Writing multi-threaded code to do this manually is difficult to write and maintain</li>
							<li>What we want is to execute a SQL like query on the collection to return a useful set of data</li>
						</ul>

						</br></br>
						<div class="fragment fade-in">
							<p>Imagine writing this manually</p>
							<pre><code data-trim class="java">
Stream&lt;String&gt; words = Stream.of("Java", "8", "FTW");
Map&lt;String, Long&gt; letterToNumberOfOccurrences =
    words.map(w -> w.split(""))
            .flatMap(Arrays::stream)
            .collect(Collectors.groupingBy(
                                Function.identity(), 
                                Collectors.counting()));
//Prints: //{a=2, T=1, F=1, v=1, W=1, 8=1, J=1}
							</code></pre>
						</div>
	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Introducing Streams!</h2>
						<ul>
							<li>A <code>Stream</code> is a conceptually fixed data structure in which elements are computed on demand</li>
							<li>Streams iterate internally, you don’t have to worry about handling the iteration</li>
							<li>Pipelining: Akin to the “pipe” command in unix, allowing aggregations to be chained together</li>
							<li>Automatic optimisation: <em>short-circuiting</em> and <em>lazy</em> processing</li>
							<li>Can be infinite</li>
							<li>Can be executed in parallel automatically using <code>parallelStream</code> or <code>paralell()</code></li>
						</ul>
	          			<aside class="notes">
	          				<ul>
	          					<li>Similar to, but not as comprehensive as LINQ</li>
	          					<li>Streams are wrappers around data sources</li>
	          					<li>Different to a List, which is an in memory data structure where every element has to be computed before it can be added</li>
								<li>Short circuiting allows the stream to end processing as soon as the result is obtained</li>
								<li>Loop fusion (fusing results together to process each one at a time rather than waiting for the whole set to pass through the intermediate operation)</li>
								<li>Lazy processing means that nothing is done until a terminal command is executed, the most efficient sequence of operations is then calculated and invoked</li>
								<li>Data can come from various sources (Collections, Arrays, IO)</li>
								<li>Don't modify the original list</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>More Streams...</h2>
						
						<ul>
							<p>Can be created from multiple sources:</p>
							<li><code>Arrays.stream(...)</code>, <code>Stream.of(1, 2, 3, 4)</code>, <code>Stream.iterate(...)</code>, <code>Stream.range(...)</code>, <code>Random.ints()</code>, <code>Files.lines(...)</code>...</li>
						
						</br>
							<p>Two types of operations:</p>
							<li><strong>Intermediate (aggregation):</strong> filter, map, flatMap, sorted ... </li>
							<li><strong>Terminal:</strong> collect, reduce, forEach, findAny ...</li>

						</br>
							<p>Specialised Streams:</p>
							<li>IntStream, LongStream and DoubleStream: better performance for those unboxed types</li>
						</ul>

	          			<aside class="notes">
	          				<ul>
	          					<li>Nothing happens until a terminal operation is called (lazy)</li>
								<li>The aggregation operations are then invoked as efficiently as possible</li>
								<li>Annoyances casting between typed streams: Steam<Int> and IntSteam</Int>
								<li>Be careful with boxing!!! Iterate not as efficient with parallel as rangeClosed (fixed number of results so can split ahead of time)</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>map</h2>

						<pre><code data-trim class="java">
public &lt;R&gt; Stream&lt;R&gt; map(Function&lt;T, R&gt; mapper)
						</code></pre>

						</br>

						<p>The <code>mapper</code> Function converts each element from <code>T</code> to <code>R</code>. The result is then added, as is, to the <code>Stream</code></p>					

	          			<aside class="notes">
	          				<ul>
	          					<li>Slightly simplified definition (removed crazy generics)</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>flatMap</h2>

						<pre><code data-trim class="java">
public &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)
						</code></pre>

						</br>

						<ul>
							<li>The <code>mapper</code> Function converts each element from <code>T</code> to a <strong><code>Stream</code></strong> of <code>R</code></li>
							<li>This is the key difference to <code>map</code>, the function itself returns a <code>Stream</code> rather than one element</li>		
							<li>This <code>Stream</code> is then <em>flattened</em> (merged) into the main <code>Stream</code></li>	
						</ul>
						</br></br>

						<p class="fragment fade-in">To put it another way: flatMap lets you replace each value of a Stream with another Stream, and then it concatenates all the generated streams into one single stream</p>	

	          			<aside class="notes">
	          				<ul>
	          					<li>Slightly simplified definition (removed crazy generics)</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>reduce</h2>

						<pre><code data-trim class="java">
public T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);
public Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);

//This is the function contained in BinaryOperator
R apply(T t, U u);
						</code></pre>

						<ul>
							<li>Normally used on combination with map</li>
							<li>Takes a <code>Stream</code> of values and repeatedly applies the accumulator to reduce them into a single value</li>
							<li>The accumulator is passed the total so far (<code>T</code>) and the current element (<code>U</code>)</li>
							<li>If passed, <code>identity</code> provides the initial value, rather than the first element</li>
						</ul>

	          			<aside class="notes">
	          				<ul>
	          					<li>More on optional later</li>
	          					<li>count, min, max, average</li>
	          					<li>Could use collectors for a lot of reduce aggregations, such as “summing”, or “counting” to count elements</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>reduce continued...</h2>

						<pre><code data-trim class="java">
loadsOfPeople.stream().
map(Person::getAge). //lets assume 3 elements: 5, 10 ,15
reduce(0, (total, current) -> total + current);
						</code></pre>

						<ul>
							<li class="fragment fade-in">First we map the <code>Person</code> to the age <code>int</code></li>
							<li class="fragment fade-in">reduce then starts at <code>0</code>, and adds the current element, <code>5</code></li>
							<li class="fragment fade-in">reduce continues by adding the current total <code>5</code>, to the next element, <code>10</code></li>
							<li class="fragment fade-in">finally reduce adds the current total <code>15</code>, to the next element <code>15</code></li>
							<li class="fragment fade-in">Tada, we've added up all the ages: <code>30!</code></li>
						</ul>

	          			<aside class="notes">
	          				<ul>
	          					<li>That's just the tip of the iceburg</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>collectors</h2>

						<p>The collect method is a terminal operation which takes various &quot;recipes&quot;, called <code>Collectors</code> for accumulating the elements of a stream into a summary result, or converting to a specific type (such as a <code>List</code>)</p>

						<pre><code data-trim class="java">
List&lt;String&gt; listOfStrings = loadsOfPeople.stream()
             .map(x -> x.getName())
             .collect(Collectors.toList());

Map&lt;Integer, List&lt;Person&gt;&gt; ageToPersonMap = 
                loadsOfPeople.stream().
                collect(Collectors.groupingBy(Person::getAge));
						</code></pre>

						<ul class="fragment fade-in">
							<li>The argument passed to collect is an object of type java .util.stream.Collector</li>
							<li>It describes how to accumulate the elements of a stream into a final result</li>
							<li>Can be used for <code>Grouping</code>, <code>Partitioning</code>, <code>Averaging</code>, ...</li>
						</ul>

	          			<aside class="notes">
	          				<ul>
	          					<li>Plenty of examples soon</li>
	          				</ul>
	          			</aside>
					</section>


					<section>
						<h2>Streams Example 1</h2>

						<pre><code data-trim class="java">
List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
List&lt;Integer&gt; twoEvenSquares =
    numbers.stream()
            .filter(n -> {//Filter out any odd numbers
                System.out.println("filtering " + n);
                return n % 2 == 0;
            })
            .map(n -> {//Multiply by itself
                System.out.println("mapping " + n);
                return n * n;
            })
            .limit(2)//Limit to two results
            .collect(Collectors.toList()); //Finish and convert to a List
						</code></pre>

<p>And the results...</p>
						<pre><code data-trim class="java">
filtering 1
filtering 2
mapping 2
filtering 3
filtering 4
mapping 4

twoEvenSquares = List[4, 16] 
						</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li>Notice we finish processing as soon as we have two results (short-circuiting)</li>
	          					<li>the filtering and mapping methods are merged together (made possible by lazy evaluation) </li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 2</h2>

						<pre><code data-trim class="java">
List&lt;String&gt; youngerPeopleSortedByIq =
                loadsOfPeople
                    .stream()
                    .filter(x -> x.getAge() &lt; 50)
                    .sorted(Comparator.comparing(Person::getIq).reversed())
                    .map(Person::getName)
                    .collect(Collectors.toList());
						</code></pre>

						<ol>
							<li>Filter out all people older than 50</li>
							<li>Inverse sort the remaining people by IQ</li>
							<li>map each person to their name (convert to a Stream&lt;String&gt;)</li>
							<li>Convert the result to a <code>List</code></li>
						</ol>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 3 - sum</h2>

						<pre><code data-trim class="java">
int combinedAge = loadsOfPeople.stream()
                    .mapToInt(Person::getAge) //converts to an IntStream
                    .sum(); //this HAS to be a specialised Stream
						</code></pre>

						<ol>
							<li>map each person to their age, producing an <code>IntStream</code></li>
							<li>sum the results, also supports <code>average</code></li>
						</ol>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 4 - map, reduce</h2>

						<pre><code data-trim class="java">
String xml = "&lt;people data='lastname'&gt;" +
              loadsOfPeople.stream()
                    .map(it -&gt; "&lt;person&gt;" + it.getName() + "&lt;/person&gt;")
                    .reduce("", String::concat) //start with "" 
           + "&lt;/people&gt;";
						</code></pre>

						<p>map each <code>Person</code> to an XML element (&lt;person&gt;Steve&lt;/person&gt;), then use String.concat to <code>reduce</code> the <code>Stream</code> into one XML <code>String</code></p>

						<pre class="fragment fade-in"><code data-trim class="java">
&lt;people&gt;
	&lt;person&gt;Dave&lt;/person&gt;
	&lt;person&gt;Helen&lt;/person&gt;
	&lt;person&gt;Laura&lt;/person&gt;
	&lt;person&gt;Ben&lt;/person&gt;
&lt;/people&gt;
						</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 5 - map</h2>

						<pre><code data-trim class="java">
List&lt;Stream&lt;Person&gt;&gt; clonedPeople = loadsOfPeople.stream()
    .map(person -> Stream.of(person, person.dolly()))
    .collect(Collectors.toList());
						</code></pre>

						<ol>
							<li>map creates a new Stream containing two people</li>
							<li>This <code>Stream</code>  is then added to the main Stream as-is, leaving us with a pretty useless: <code>List&lt;Stream&lt;Person&gt;&gt;</code></li>
						</ol>
						<img class="fragment fade-in" src="images/Meh-Grumpy-Cat.jpg"/>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 6 - flatMap</h2>

						<pre><code data-trim class="java">
List&lt;Person&gt; clonedPeople2 = loadsOfPeople.stream()
        .flatMap(person -> Stream.of(person, person.dolly()))
        .collect(Collectors.toList());
						</code></pre>

						<ol>
							<li>flatMap combines each element from the new <code>Streams</code> into one <code>Stream&lt;Person&gt;</code></li>
							<li>So now we've got what we wanted in the first place, a <code>List&lt;Person&gt;</code></code></li>
						</ol>
						<div class="fragment fade-in">							
							<img  src="images/woojesus.jpeg"/>
							<p>Sweeet!</p>
						</div>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 7 - Reduce</h2>

						<pre><code data-trim class="java">
int totalAgeUsingReduce = loadsOfPeople.stream().
        map(Person::getAge).
        reduce(0, (total, current) -> total + current);
						</code></pre>

						<ol>
							<li>map from <code>Person</code> to age</li>
							<li>reduce starts with a value of 0, then adds the value of each element to the total, giving us the total age</li>
						</ol>
	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 8 - Reduce</h2>

						<pre><code data-trim class="java">
int youngestUsingReduce = loadsOfPeople.stream().
        map(Person::getAge).
        reduce((total, current) -> total + current).
        get(); //get the result from the Optional
						</code></pre>

						<ul>
							<li>This is the same as the previous example, the difference being we don't specify a default value for reduce</li>
							<li>Not specifying a default value means the result is <code>Optional</code>... if the <code>Stream</code> is empty then so is the result!</li>
						</ul>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 9 - Grouping</h2>

						<pre><code data-trim class="java">
Map&lt;Integer, List&lt;Person&gt;&gt; peopleGroupedByAge =
        loadsOfPeople.stream().
        filter(x -> x.getIq() > 110).
        collect(Collectors.groupingBy(Person::getAge));
						</code></pre>

						<ul>
							<li>The collect method groups the filtered results by age, producing a Map&lt;age, &lt;Person&gt;&gt;</li>
						</ul>

						<pre class="fragment fade-in"><code data-trim class="java">
{52=[Person{name='Damo', age=52, iq=113, gender=MALE}],
 60=[Person{name='Jess', age=60, iq=120, gender=FEMALE}],
 28=[Person{name='Dave', age=28, iq=190, gender=MALE}]}
						</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 10 - Partitioning</h2>

						<pre><code data-trim class="java">
Map&lt;Boolean, List&lt;Person&gt;&gt; peoplePartitionedByAge = 
        loadsOfPeople.stream().filter(x -> x.getIq() > 110).
        collect(Collectors.partitioningBy(x -> x.getAge() > 55));
						</code></pre>

						<ul>
							<li>The collect method partitions the filtered results by age</li>
							<li>The <code>Map</code> will have two entries, true and false, according to the <code>Predicate</code></li>
						</ul>

						<pre class="fragment fade-in"><code data-trim class="java">
{false=[Person{name='Dave', age=28, iq=190, gender=MALE}],
 true=[Person{name='Jess', age=60, iq=120, gender=FEMALE}]}
						</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 11 - Multiple Groups</h2>

						<pre><code data-trim class="java">
Map&lt;Integer, Double&gt; peopleGroupedBySexAndAverageAge = 
        loadsOfPeople.stream().filter(x -> x.getIq() > 110).
        collect(Collectors.groupingBy(Person::getAge,
                    Collectors.averagingInt(Person::getIq)));
						</code></pre>

						<ul>
							<li>We can group by multiple <code>Collectors</code></li>
							<li>Here we group by age and the average IQ of that group</li>
						</ul>

						<pre class="fragment fade-in"><code data-trim class="java">
{52=113.0, 60=117.5, 28=190.0}
						</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 12 - findAny</h2>

						<pre><code data-trim class="java">
loadsOfPeople.stream()
        .filter(t -> t.getGender() == Person.Sex.FEMALE)
        .findAny()
        .ifPresent(System.out::println);
						</code></pre>

						<ul>
							<li><code>findAny</code> either returns an element or nothing, hence we get an Optional</li>
							<li><code>ifPresent</code> executes the Lambda if we get a result</li>
						</ul>

	          			<aside class="notes">
	          				<ul>
	          					<li></li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 13 - Parallel</h2>
						<p>Lets iterate over 10,000,000 elements!</p>
						</br>

						<pre><code data-trim class="java">
x -> Stream.iterate(1L, i -> i + 1).
        limit(x).
        reduce(Long::sum).get();
						</code></pre>
						<p>Executes in 80ms - we incur a penalty here because the <code>long</code> is repeatedly boxed and unboxed</p>

						<div class="fragment fade-in">
							<pre><code data-trim class="java">
x -> Stream.iterate(1L, i -> i + 1).
        parallel().limit(x).
        reduce(Long::sum).get();
							</code></pre>
							<p>Executes in 211ms?! It turns out parallel isn't always a free win!</p>
						</div>

	          			<aside class="notes">
	          				<ul>
	          					<li>This proves just tagging parallel on the stream isn't always a win!</li>
								<li>Parallel works much better on fixed lists, not dynamic ones</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Streams Example 14 - Parallel Win!</h2>

						<pre><code data-trim class="java">
x -> LongStream.rangeClosed(1L, x).
        reduce(Long::sum).getAsLong();
						</code></pre>
						<p>Executes in 24ms - much better using an unboxed <code>Stream</code></p>

						<div class="fragment fade-in">
							<pre><code data-trim class="java">
x -> LongStream.rangeClosed(1L, x).
        parallel().
        reduce(Long::sum).getAsLong();
							</code></pre>
							<p>Executes in 7ms - now that the <code>Stream</code> isn't dynamic, parallel works much better!</p>
						</div>

	          			<aside class="notes">
	          				<ul>
	          					<li>This proves just tagging parallel on the stream isn't always a win!</li>
								<li>Parallel works much better on fixed lists, not dynamic ones</li>
	          				</ul>
	          			</aside>
					</section>
				</section>

				<section>
					<h2>It's been emotional...</h2>
			        <ul>
			        	<li>Slides at <a href="http://markglh.github.io/Java8Madlab-Slides">markglh.github.io/Java8Madlab-Slides</a>,</li>
			         	<li>Source at <a href="https://github.com/markglh/Java8Madlab-Examples">github.com/markglh/Java8Madlab-Examples</a>,</li>
			         	<li>Follow me <a href="https://twitter.com/markglh">@markglh</a>,</li>
			        </ul>
				</section>

			</div>

		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
