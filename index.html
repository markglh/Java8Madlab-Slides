<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="Java 8 - The Good Stuff!">
		<meta name="author" content="Mark Harrison">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Java 8 - The Good Stuff</h1>
					<h3>Lambdas, Streams, Optional...</h3>
					<p>
						<small>Created by <a href="https://github.com/markglh">Mark Harrison</a> / <a href="http://twitter.com/markglh">@markglh</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>Lambdas you say?</h2>
						<ul>
	         				<li>Basically just a shorthand method implementation</li>
	         				<li>Concise and <em>much</em> improved replacement for Anonymous inner classes</li>
	         				<li>Makes it easy to pass <em>behaviour</em> around</li>
	          				<li>Pass the behaviour into the method, flips the design on its head</li>
	          				<li>Lexically scoped (<code>this</code> is effectively shared with the surrounding method)</li>
	          				<li><em>Almost</em> closures</li>
	          			</ul>
						</p>
	          			<aside class="notes">
	          				<ul>
	          					<li>Lexical scoping - effectively recognises the scope of the surrounding method.</li>
	          					<li>“this” doesn’t refer to the lambda itself (as it would have with anonymous classes).</li>
	          					<li>lambdas can access the variables of the surrounding method (making them closures, almost)</li>
	          					<li>One caveat here is that the variables must be effectively final, they don’t need to have the final keyword, but the compiler will verify that they aren’t re-assigned.</li>
	          					<li>good performance, better than scala (sorry!)</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Syntax please!</h2>

						<pre><code data-trim class="java">
(int x, int y)   ->   x + y
	          			</code></pre>
	          			</br>

	          			<p>Argument types can be inferred by the compiler:</p>
	          			<pre><code data-trim class="java">
(x, y)   ->   x + y
	          			</code></pre>

	          			</br>

						<p>Zero-arg Lambdas are also possible:</p>
	          			<pre><code data-trim class="java">
()   ->   "Java 8!"
	          			</code></pre>
	          			</br>

						<p>But how can we use them?</p>
						<pre class="fragment fade-in" ><code data-trim class="java">
Consumer&lt;String&gt; inferredConsumer = x -> System.out.println(x);
	          			</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li>Multiple arguments need to be in parentheses</li>
	          					<li>The types can be inferred when mapping to the FunctionalInterface</li>
	          					<li>Can wrap large Lambdas in parenthesis but you should really use method references instead</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>WAT?!?</h2>
						<img src="images/watcat.jpg"/>
					</section>

					<section>
						<h2>Functional Interfaces</h2>
						<ul>
							<li>A Functional Interface is any interface with <em>one</em> <strong>S</strong>ingle <strong>A</strong>bstract <strong>M</strong>ethod</li>
							<li class="fragment fade-in">The parameters that the Lambda accepts and returns must match the interface (incuding exceptions)</li>
							<li class="fragment fade-in"><code>@FunctionalInterface</code> annotation is provided to highlight these interfaces, it is just a marker though, any <em>SAM</em> interface will work - the annotation simply enforces this at compile time</li>
						</ul>
						</ul>
						</br></br>
						<ul class="fragment fade-in">
							<li>So... When we pass or assign a Lambda:
								<ol>
									<li>First the Lambda is converted into a Functional Interface</li>
									<li>Secondly it is invoked via this generated implementation</li>
								</ol>	
							</li>
						</ul>						

	          			<aside class="notes">
	          				<ul>
	          					<li>A @FunctionalInterface has one (non default) method. </li>
	          					<li>Inference is used to try to match the interface to the lambda</li>
	          					<li>The annotation is just a marker, it isn't required for it to work, any interface with just one method is considered a functional interface!</li>
	          					<li>However, if the interface has more than one (non-default) method the annotation prevents it from compiling.</li>
	          					<li>Fully backwards compatible.</li>
	          					<li>A Lambda can replace any variable or parameter that expects a SAM interface</li>
	          					<li>The java.util.function package contains lots of <code>@FunctionalInterface</code> definitions</li>
	          					<li>Downside: Lots of different interfaces with different names (couldn’t do it like C# because of type erasure)</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 1 - Predicates</h2>
						<p>Have you ever written code like this?</p>

						<pre><code data-trim class="java">
@FunctionalInterface  //Added in Java8 
public interface Predicate&lt;T&gt; {
	boolean test(T t); 
	
}

private void printAllPeopleMatchingPredicate(List&lt;Person&gt; people, 
                                             Predicate&lt;Person&gt; predicate) {
    for (Person person : people) {
        if (predicate.test(person)) {
           System.out.println(person);
        }
    }
}						
						</code></pre>

	          			<aside class="notes">
	          				<ul>
	          					<li>Predicate pattern, rather than hard coding the "if" statement</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 1 - Predicates</h2>

						<p>Pre Java 8:</p>

						<pre><code data-trim class="java">
class PersonOlderThan50Predicate implements Predicate&lt;Person&gt; {
    public boolean test(Person person) {
        return person.getAge() >= 50;
    }
}

printAllPeopleMatchingPredicate(loadsOfPeople, 
                                new PersonOlderThan50Predicate());
	          			</code></pre>
	          			</br>

	          			<aside class="notes">
	          				<ul>
	          					<li>Need to implement a predicate for each different test</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 1 - Predicates</h2>

						<p>Java 8:</p>

						<pre><code data-trim class="java">
printAllPeopleMatchingPredicate(loadsOfPeople, x -> x.getAge() > 50); 
	          			</code></pre>
	          			<p>Notice the signature matches that of the Predicate, the compiler automatically figures out the rest</p>
	          			</br>

	          			
		          		<p>What if we had an existing <code>Predicate</code> we wanted to enhance?</p>
		          		<div class="fragment fade-in">
		          			<pre><code data-trim class="java">
Predicate&lt;Person&gt; ageCheck = x -> x.getAge() > 50;
printAllPeopleMatchingPredicate(loadsOfPeople, 
                                ageCheck.and(x -> x.getIq() >100));
		          			</code></pre>
		          			<p>Composite <code>Predicates</code> FTW... :-)</p>
	          			</div>


	          			<aside class="notes">
	          				<ul>
	          					<li>Could pass another function in to execute on each element</li>
	          					<li>Execute around pattern</li>
	          					<li>Could use method references instead</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 2 - Runnable</h2>

						<p>Pre Java 8 mess:</p>

						<pre><code data-trim class="java">
Runnable r1 = new Runnable() {
    @Override
    public void run() {
         System.out.println("Meh!");
    }
};
r1.run();
	          			</code></pre>

	          			</br>
						<p>Java 8:</p>

						<pre><code data-trim class="java">
Runnable r = () -> System.out.println("Woop!");
r.run();
	          			</code></pre>
					</section>

					<section>
						<h2>Lambda Example 3 - Collections</h2>

						<p>Lambdas make lots of new Collection methods possible...</p>

						<pre><code data-trim class="java">
List&lt;String&gt; strings = new ArrayList&lt;&gt;();
Collections.addAll(strings, "Java", "7", "FTW");
	          			</code></pre>
	          			
	          			<div class="fragment fade-in">
	          			<p>Do <em>something</em> on every element in the List</p>
	          			<pre><code data-trim class="java">
strings.forEach(x -> System.out.print(x + " ")); 
//Prints: "Java 7 FTW"
	          			</code></pre>
	          			</div>
	          			
	          			<div class="fragment fade-in">
	          			<p>Replace every matching element in the List</p>
	          			<pre><code data-trim class="java">
strings.replaceAll(x -> x == "7" ? "8" : x); 
strings.forEach(x -> System.out.print(x + " "));
//Prints: "Java 8 FTW"
	          			</code></pre>
	          			</div>

						<div class="fragment fade-in">
	          			<p>Remove matching elements from the List</p>
	          			<pre><code data-trim class="java">
strings.removeIf(x -> x == "8");
strings.forEach(x -> System.out.print(x + " "));
//Prints: Java FTW
	          			</code></pre>
	          			</div>

	          			<aside class="notes">
	          				<ul>
	          					<li>This sets us up for streams later</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Lambda Example 4 - Comparators</h2>

						<pre><code data-trim class="java">
@FunctionalInterface //Added in Java8 version
public interface Comparator&lt;T&gt; {
	int compare(T o1, T o2);
	//Java 8 adds loads of default methods...
}
						</code></pre>

						<p>Pre Java 8:</p>

						<pre><code data-trim class="java">
class SortByPersonAge implements Comparator&lt;Person&gt; {
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge();
    }
}

List&lt;Person&gt; loadsOfPeople = ...;
Collections.sort(loadsOfPeople, new SortByPersonAge());

	          			</code></pre>

	          			<div class="fragment fade-in">
	          			<p>Java 8:</p>

						<pre><code data-trim class="java">
Collections.sort(loadsOfPeople, (p1, p2) -> p1.getAge() - p2.getAge());
	          			</code></pre>
	          			</div>

	          			<aside class="notes">
	          				<ul>
	          					<li>Multiple arguments need to be in parenthesis</li>
	          					<li>The types can be inferred when mapping to the FunctionalInterface</li>
	          				</ul>
	          			</aside>
					</section>
				</section>

				<section>
						<h2>Lambda Example 4 - Comparators</h2>

						<p>As usual in Java 8... the <code>Comparator</code> interface provides plenty of useful default &amp; static methods...</p>
			
						<pre><code data-trim class="java">
//comparing static method simplifies creating Comparators
Comparator&lt;Person&gt; newComparator = Comparator.comparing(e -> e.getIq());
						</code></pre>

						<pre class="fragment fade-in"><code data-trim class="java">
//thenComparing allows composite comparators to be easily created
Collections.sort(loadsOfPeople, 
                 newComparator.thenComparing(
                               Comparator.comparing(e -> e.getIq())));
						</code></pre>

						<pre class="fragment fade-in"><code data-trim class="java">
//More useful Collection methods...
loadsOfPeople4.sort(Comparator.comparing(e -> e.getIq()));
						</code></pre>

						<pre class="fragment fade-in"><code data-trim class="java">
//And finally... Method references (I'll explain this soon!)
loadsOfPeople.sort(Comparator.comparing(Person::getAge));
						</code></pre>

	          			
	          			<aside class="notes">
	          				<ul>
	          					<li>Multiple arguments need to be in parenthesis</li>
	          					<li>The types can be inferred when mapping to the FunctionalInterface</li>
	          				</ul>
	          			</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Introducing Method References</h2>
						<ul>
							<li>Any method can be automatically “lifted” into a function. It must simply meet contract of the FunctionalInterface</li>
	          				<li>Can be easier to debug &amp; test than Lambdas, more descriptive stack traces</li>
	          				<li>Promotes re-use, keeping code <em>DRY</em></li>
	          				<li>Uses the &quot;<em>::</em>&quot; syntax</li>
	          			</ul>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Decision needs to be made on a case by case basis</li>
	          					<li>Generally method references are more readable and certainly more re-usable</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Method References Types</h2>
	          			<table>
							<thead>
								<tr>
									<th>Reference to...</th>
									<th>Example</th>
								</tr>
							</thead>
							<tbody>
								<tr>
								 	<td>a static method</td>
								 	<td><code class="java">Class::staticMethodName</code></td> 
								</tr>
								<tr>
									<td>an instance method of a <strong>specific</strong> object</td>
									<td><code class="java">Object::instanceMethodName</code></td> 
								</tr>
								<tr>
									<td>an instance method of an <strong>arbitrary</strong> object</td>
									<td><code class="java">Class::methodName</code></td> 
								</tr>
								<tr>
									<td>a constructor</td>
									<td><code class="java">ClassName::new</code></td> 
								</tr>
							</tbody>
						</table>
					</section>

					<section>
						<h2>Reference to a static method</h2>
						<p>A simple reference to a static method</p>
						<pre><code data-trim class="java">
//isPersonOlderThan50 is a static method on the PersonPredicates class
printAllPeopleMatchingPredicate(loadsOfPeople, 
                                PersonPredicates::isPersonOlderThan50);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
printAllPeopleMatchingPredicate(loadsOfPeople, x -> x.getAge() > 50);
						</code></pre>
	          			<aside class="notes">
	          				<ul>
	          					<li>...</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Reference to an instance method of a specific object</h2>
						<p>A reference to a method on an object instance</p>
						<pre><code data-trim class="java">
List&lt;String&gt; strings = ...
//print is a method on the "out" PrintStream object
strings.forEach(System.out::print);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
strings.forEach(x -> System.out.print(x));
						</code></pre>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Useful for saving a few characters but not the most widely used type</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Reference to an instance method of an arbitrary object</h2>
						<p>Although it looks like we're referencing a Class method, we're invoking an instance method on the object(s) passed in the call</p>
						<pre><code data-trim class="java">
public interface Function&lt;T,R&gt; {
	public R apply(T t);
}

public static &lt;T, R&gt; List&lt;R&gt; map(Function&lt;T, R&gt; function, List&lt;T&gt; source) {
        //applies the function to each element, converting it from T to R
}
						</code></pre>
						<pre><code data-trim class="java">
List&lt;Person&gt; loadsOfPeople = ...
List&lt;Integer&gt; namesOfPeople = map(Person::getAge, loadsOfPeople);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
List&lt;Integer&gt; namesOfPeople = map(person -> person.getAge(), loadsOfPeople);
						</code></pre>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Useful for saving a few characters but not the most widely used type</li>
	          				</ul>
	          			</aside>
					</section>

					<section>
						<h2>Reference to a constructor</h2>
						<p>Uses the constructor to create new objects, the constructor signature must match that of the FunctionalInterface</p>
						<pre><code data-trim class="java">
List&lt;String&gt; digits = Arrays.asList("1", "2", "3", "4", "5");
						</code></pre>
						<pre><code data-trim class="java">
//Transforms a String into an Integer using the default Integer constructor
List&lt;Integer&gt; numbers = map(Integer::new, digits);
						</code></pre>
	          			</br>

	          			<p>This is equivalent to</p>
	          			<pre><code data-trim class="java">
List&lt;Integer&gt; numbers2 = map(s -> new Integer(s), digits);
						</code></pre>
						
	          			<aside class="notes">
	          				<ul>
	          					<li>Anytime you're simply creating a new object you may be able to swap the lambda for a constructor method reference</li>
	          				</ul>
	          			</aside>
					</section>
				</section>




				<section>
					<h2>Stellar Links</h2>
					<ul>
						<li><a href="http://slid.es">Try the online editor</a></li>
						<li><a href="https://github.com/hakimel/reveal.js">Source code on GitHub</a></li>
						<li><a href="http://twitter.com/hakimel">Follow me on Twitter</a></li>
					</ul>
				</section>

				<section>
					<h1>THE END</h1>
					<h3>BY Hakim El Hattab / hakim.se</h3>
				</section>

			</div>

		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
